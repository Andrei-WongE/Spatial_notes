---
title: "Spatial data: OSM_Notes"
author: "[Andrei Wong](https://github.com/Andrei-WongE)"
date: "June 1, 2022"

format:
  html:
# Basic options
    fontcolor: black
    # By default, smooth scroll is not enabled
    smooth-scroll: true
# Add table of contents
    toc: true
    toc_float: true
    toc-location: left
# css selectors to change the header and TOC styles
    css: headers.css
    number-sections: true
    smooth-scroll: true
    link-external-icon: false
    link-external-newwindow: true
    theme: lux
    highlight-style: github
# Fold code (initially hidden)
    code-fold: true
# Allow to download code
    code_download: yes
# Code link to documentation   
    code-link: true
# Tables printed as HTML tables with support for pagination
    df_print: paged
# Table options    
    table-captions: true
    tbl-cap-location: margin
# Places footnotes and cited sources in the margin
# other layout options (for example placing a 
# figure in the margin) will be set on per element
# using cap-location margin
    reference-location: margin
    citation-location: margin 
# Text for footer
    include-after-body: footer.html
# Allow for highlighting text. \hl{highlight} text inline.Or \hl{\textbf{highlight}} with bold face.
# Allows fort commenting using hypothesis
comments:
  hypothesis: true

execute:
  warning: false
  message: false
  cache: true
---

# Set-up

```{r}
#| echo: false
knitted_when <- format(Sys.Date())
knitted_where <- knitr::current_input()
knitted_with <- packageVersion("knitr")
knitted_doc_url <- downlit::autolink_url("knitr::knit()")
```

Note updated on `r knitted_when` from `r knitted_where` with knitr version `r knitted_with`.

::: {.callout-note collapse="false"}
## General set-up of the program.
These notes make use of the following R packages and general set-up.
:::

```{r Set-up}
#| label: set-up

  if (!require("pacman")) {
  install.packages("pacman")
  }

  pacman::p_load(tidyverse 
                 ,tidylog
                 ,Cairo
                 ,here
                 ,dplyr
                 ,crsuggest  # Suggest CRS information for spatial data
                 ,ggplot2
                 ,ggnewscale # For multiple fill and colour scales in ggplot2
                 ,ggsn       # North Symbols and Scale Bars for Maps
                 ,osmdata    # For downloading and using data from OSM
                 ,sf         # DONT'T FORGET uses the s2geometry library
                 ,knitr
                 ,rvest      # For Web scrapping
                 ,DT         # R interface to the JavaScript library DataTables
                 ,downlit    # For syntax highlighting and automatic linking
                 ,git2r      # Provides access to 'Git' repositories
                 ,xfun       # For alternative Session Info
                 )
  
  #pacman::p_update()         # Update out-of-date packages

  options(scipen = 100, digits = 2)             # Prefer non-scientific notation
  
  knitr::opts_chunk$set( dev       = "CairoPNG" # Alpha transparency in png
                        ,fig.path  = "Figs/"
                        ,dpi       = 600
                        ,fig.width = 12
                        ,fig.hight = 12
  # Automatically formatting code using styler
                        ,tidy      = "styler"
)

```

# Obtaining data
Using `osmdata` package you can download data from [OSM](https://www.openstreetmap.org/about). Consider that this package provides access to vector data while the `OpenStreetMap` package to <mark >raster tiles</mark>.
For more information about `OpenStreetMap` see [here](http://blog.fellstat.com/?cat=15).

```{r data}
#| label: data
#| code-fold: show

Lima <-
   getbb("Lima Metropolitana") |>     # obtaining boundaries
   opq(timeout = 20*100) |>           # overpass query
   add_osm_feature(                   # retrieve administrative boundaries
     key = "admin_level"
    ,value = "5"                      # boundary box at the met level
  ) |>
  osmdata_sf()                        # import as an sf object

```
Dowloaded data timestamp: `r Lima$meta$timestamp`.

# Obtaining boundaries

```{r boudndaries}
#| label: boundaries
#| code-fold: show

Lima_multipolygons <- Lima |>                     
(\(x) osm_multipolygons(x, x$osm_polygons$osm_id)) () |>  # extracting polygons
  dplyr::filter(name == "Lima Metropolitana") |> # only at specific city level
  dplyr::select(geometry) 

```
`suggest_crs()` from the **crsuggest package** returns the top 10 matches for a given input spatial dataset enabeling to browse the returned CRS option and use the EPSG/proj4string codes in your analysis. This package is usefull for customizing arguments (gcs and measurement units) as guessing the CRS of a dataset without projection information.

```{r crs}
#| label: crs
#| code-fold: show
#| tbl-cap: "Possible CRS"

possible_crs <- suggest_crs(Lima_multipolygons)
kable(head(possible_crs, "simple"))

```
Now we can covert the GIS coordinates to CRS using `st_transform`

```{r object}
#| label: object
#| code-fold: show

# convert the GIS coordinates to CRS
Lima_multipolygons <- st_transform(Lima_multipolygons, 24892) 

Lima_multipolygons
```


See [OPQ](https://wiki.openstreetmap.org/wiki/Overpass_API#Resource_management_options_.28osm-script.29) for explanation of timeout and memsize (or maxsize in overpass terms). 
See ESPG codes on [spatialreference.org](https://spatialreference.org/ref/epsg/).
See [nominatim](https://nominatim.openstreetmap.org/ui/details.html?osmtype=N&osmid=4289361265&class=place) for **admin_level** keys.
Search for feature in the following table.

```{r tbl-osm-features}
#| label: tbl-osm-features
#| tbl-cap: "OSM features table"
#| caption: OSM_features

page <- read_html("https://wiki.openstreetmap.org/wiki/Map_features")

features_list <- html_nodes(page,  css = ".toctext") |> 
  html_text2() |> 
  as.data.frame() |> 
  rename(feature = starts_with("html"))

datatable(features_list,
  options = list(
    searchHighlight = TRUE
    ,dom = "ltipr"            # Deactivate search box
    )
  ,filter = "top"             # Deactivate search box
  ,selection = "multiple",    # Deactivate search box
  ,escape = FALSE             # Deactivate search box
  ,width = "300px"
)
```

In order to select [Features](https://wiki.openstreetmap.org/wiki/Map_Features) there is a list available with `r nrow(features_list)` features, as shown in @OSM_features. We can also use the `available_features( )` function that returns a list of available OSM features that have different tags.

If we look to the internal structure of the resulting object, we obtain:

```{r sf-object-structure}
#| label: sf-object-structure
#| echo: false
str(Lima)
```

```{r first-plot}
#| label: first-plot
#| fig-cap: "First general plot of the city."
#| cap-location: margin
#| echo: false
#| code-fold: show


ggplot(Lima_multipolygons, fill = NA) +
  geom_sf() +
  ggsn::blank()

```

<!-- ![First plot.](r`knitr::fig_chunk('Figs/first-plot','png')`) -->

# Adding data: Streets, buildings, and population density

```{r obtaining-data-roads}
#| label: adding-data-roads
#| code-fold: show

roads <-
 getbb("Lima Metropolitana") %>% 
 opq(timeout = 20*110) %>%
 add_osm_feature(                   # requesting features related to highway
     key = "highway" 
    ,value = c(
       "trunk"
      ,"primary"
      ,"secondary"
      # ,"tertiary"
      )
  ) %>% 
  osmdata_sf()

```

```{r wrangling-data-roads}
#| label: wrangling-data-roads
#| code-fold: show

roads_sf <- roads |>  
  (\(x) osm_lines(x, x$osm_lines$osm_id))() |>
  # which means using other type of geometry
  dplyr::select(geometry) |>
  st_transform(24892) |> 
  st_intersection(Lima_multipolygons) |>          # only highways in the city
  dplyr::filter(st_is(geometry, c("LINESTRING"))) # assure only line geometry

```

```{r roads-plot}
#| label: roads-plot
#| echo: false
#| fig-cap: "Adding layer of roads to map."
#| cap-location: margin
#| code-fold: show

ggplot() +
  #---The layer added later will come on top of the preceding layers---#
  geom_sf(data = Lima_multipolygons) +
  geom_sf(data = roads_sf) +
  ggsn::blank()

```

```{r obtaining-buildings-data}
#| label: adding-data-roads
#| code-fold: show

buildings_sf <-
  getbb("Lima Metropolitana") |> 
  opq(timeout = 20*100) |> 
  add_osm_feature(
    key = "building", 
    value = c(
      # Accommodation
      "apartments", "house", "residential" 
      #Commercial
      , "commercial", "office", "retail", "supermarket"
      # Religious
      ,"cathedral","church"
      # Civic/amenity
      , "civic", "college", "government", "	hospital", "public", "transportation", "university"
      # Other buildings
      , "bridge"
    )
  ) |> 
  osmdata_sf() 

buildings_sf <- buildings_sf |>  
  (\(x) osm_polygons(x, x$osm_polygons$osm_id))() |> 
  dplyr::select(geometry) |> 
  st_transform(24892) |>  
  st_intersection(Lima_multipolygons)
```

```{r buildings-plot}
#| label: buildings-plot
#| echo: false
#| fig-cap: "Adding layer of buildings to map."
#| cap-location: margin
#| code-fold: show

ggplot() +
  #---The layer added later will come on top of the preceding layers---#
  geom_sf(data = Lima_multipolygons) +
  geom_sf(data = buildings_sf) +
  ggsn::blank()

```

For obtaining population data we use data from the National Institute of Statistics and Informatics (INEI, 2018).

```{r obtaining-population-data}
#| label: otaining-population-data
#| code-fold: show

  population <- st_as_sf(st_read(here("data", "EstratoLimaMetropolitanashp.shp"))) 

```
Population data is in geodetic CRS, we need to transform this data to Projected CRS. More details about the difference between these systems [here](https://www.earthdatascience.org/courses/use-data-open-source-python/intro-vector-data-python/spatial-data-vector-shapefiles/geographic-vs-projected-coordinate-reference-systems-python/).

```{r wrangling-population-data}
#| label: wrangling-population-data
#| code-fold: show

population_sf <- population |> 
  st_transform(24892) |> # Extra care is needed with the ESRI Shapefile format, because WKT1 does not store axis order unambigiously.
  st_intersection(Lima_multipolygons)

```

```{r population-plot}
#| label: population-plot
#| echo: false
#| fig-cap: "Adding layer of population to map."
#| cap-location: margin
#| code-fold: show

ggplot() +
  #---The layer added later will come on top of the preceding layers---#
  geom_sf(data = Lima_multipolygons) +
  geom_sf(data = population_sf) 

```
## Tilting sf objects

Following [Stefan Jünger](https://stefanjuenger.github.io/gesis-workshop-geospatial-techniques-R/slides/2_4_Advanced_Maps_II/2_4_Advanced_Maps_II.html#4) we will til each sf object by:
  1. displace each point in a fixed direction, by an amount proportional to its signed distance from the line that is parallel to that direction and goes through the origin, while preserving the size of the area (shearing),
  2. rotate each plane / layer, and
  3. offset x and/or y axis.
  
  
  
::: {.column-margin}
  Function to tilt sf objects, code by [Stefan Jünger](https://stefanjuenger.github.io/gesis-workshop-geospatial-techniques-R/slides/2_4_Advanced_Maps_II/2_4_Advanced_Maps_II.html#4)
:::

```{r tilting-function}
#| label: tilting-function
#| echo: false
#| cap-location: margin
#| code-fold: show

rotate_data <- function(data, x_add = 0, y_add = 0) {
  shear_matrix <- function() {
    matrix(c(2, 1.2, 0, 1), 2, 2)
  }
  rotate_matrix <- function(x) {
    matrix(c(cos(x), sin(x), -sin(x), cos(x)), 2, 2)
  }
  data %>%
    dplyr::mutate(
      geometry =
        .$geometry * shear_matrix() * rotate_matrix(pi / 20) + c(x_add, y_add)
    )
}
```




<!-- ![Roads plot.](r`knitr::fig_chunk('Figs/roads-plot','png')`) -->

# Visualize data with sfmap, ggplot2, ggmap, tmap and leaflet

::: {.panel-tabset}
## sfmap

```{r}

```
## ggplot2

```{r}
ggplot() +
  geom_sf(data = Lima_multipolygons) +
  geom_sf(
    data = population_sf,
    aes(fill = layer,
        alpha = 0.8), 
    color = NA
  )) +
  scale_fill_distiller(
    palette = "YlOrBr", 
    direction = 1,
    guide = FALSE
  ) +
  geom_sf(data = roads_sf) +
  geom_sf(data = buildings_sf) +
  theme(legend.position = "none") 

```

## ggmap
## tmap
## leaflet

:::


# Appendix:

<details>

<summary>

All code for this report

</summary>

```{r ref.label = knitr::all_labels()}
#| eval: false
#| code-fold: false
```

</details>

<details>

<summary>

Reproducibility receipt

</summary>

```{r Reproducibility receipt}
#| echo: false

      ## Datetime
      Sys.time()
  
      ## Repository
      git2r::repository()
  
      ## session info
      xfun::session_info()
      
```

</details>

<div class="watermark">DRAFT</div>
